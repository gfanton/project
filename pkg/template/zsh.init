# compdef p
# mostly from: https://github.com/ajeetdsouza/zoxide/blob/main/templates/zsh.txt

function __project_pwd() {
    \builtin pwd -L
}

function __project_cd() {
    \builtin cd -- "$@" && echo "switched to '$@'"
}

function __project_p() {
    # shellcheck disable=SC2199
    if [[ "$#" -eq 0 ]]; then
        __project_cd ~
    elif [[ "$#" -eq 1 ]] && [[ "$1" = '-' ]]; then
        if [[ -n "${OLDPWD}" ]]; then
            __project_cd "${OLDPWD}"
        else
            # shellcheck disable=SC2016
            \builtin printf 'project: $OLDPWD is not set'
            return 1
        fi
    elif [[ "$#" -eq 1 ]] && [[ -d "$1" ]]; then
        __project_cd "$1"
    # elif [[ "$@[-1]" == "${__project_z_prefix}"* ]]; then
    #     # shellcheck disable=SC2124
    #     \builtin local result="${@[-1]}"
    #     __project_cd "{{ "${result:${#__project_z_prefix}}" }}"
    else
        \builtin local result
        # shellcheck disable=SC2312
        result="$(\command {{.Exec}} query --abspath --exclude "$(__project_pwd)" -- "$@")" &&
            __project_cd "${result}"
    fi
}

# Completions.
# Check if the Zsh Line Editor (zle) is available. 
# If it's not, none of the rest of the code within this if statement block will execute.
if [[ -o zle ]]; then
    # Define a function called __project_p_complete that implements the custom completion behavior for the project command.
    function __project_p_complete() {
        \builtin local -a reply
        \builtin local -a descriptions
        \builtin local result
        \builtin local line

        # Check if the cursor is at the end of the line. 
        # If not, the function returns immediately.
        # ${#words[@]} gives the count of words in the command line 
        # and ${CURRENT} contains the index of the word at the cursor position.
        [[ "{{ "${#words[@]}" }}" -eq "${CURRENT}" ]] || return 0

        # Query project for up to 20 potential directory matches
        # Using --limit 20 to show multiple options for cycling
        input="$(\command {{.Exec}} query --limit 20 --exclude "$(__project_pwd)" -- ${words[2,-1]} 2>/dev/null)"
        
        if [[ ! -z "${input// }" ]]; then
            # Split input into array
            reply=("${(@f)input}")
            
            # Create descriptions for each match to show more context
            descriptions=()
            for project in "${reply[@]}"; do
                # Add description showing the full path context
                if [[ "$project" == */* ]]; then
                    descriptions+=("$project:project")
                else
                    descriptions+=("$project:project")
                fi
            done
            
            # Use compadd with descriptions and enable cycling through options
            # -d: descriptions array
            # -l: enable list always (show multiple options)
            # -o: enable completion cycling
            # -J: completion group name
            compadd -d descriptions -l -o -J projects -a reply
        fi
        
        # Send a Device Status Report (DSR) code to the terminal. 
        # This is typically used for checking if the terminal is still responding.
        \builtin printf '\e[5n'

        return 0
    }

    # Bind the reset-prompt widget to the '\e[0n' key sequence. 
    # This sequence corresponds to the terminal's response to the DSR code mentioned above.
    \builtin bindkey '\e[0n' 'reset-prompt'

    # Configure completion behavior for better cycling experience
    # Enable menu selection for project completions
    zstyle ':completion:*:*:__project_p:*' menu select
    zstyle ':completion:*:*:__project_p:*' list-colors ''
    zstyle ':completion:*:*:__project_p:*' group-name projects
    zstyle ':completion:*:projects:*' format '%B%F{blue}Projects:%f%b'
    
    # Check if compdef function is available. 
    # If it is, register the __project_p_complete function as the completion function for the __project_p command.
    [[ "${+functions[compdef]}" -ne 0 ]] && \compdef __project_p_complete __project_p
fi

\builtin unalias p &>/dev/null || \builtin true
\builtin alias p=__project_p

# To initialize project, add this to your configuration (usually ~/.zshrc):
#
# eval "$(project init zsh)"
